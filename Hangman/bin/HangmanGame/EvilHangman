package HangmanGame;

import java.util.Random;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This class describes traditional hangman game.
 * Once the word is selected, it will not change.
 * @author Xueqi Wang, Weijie Qi
 */
public class EvilHangman extends Hangman {
	
	/**
	 * "word": a randomly selected word for user to guess.
	 */
	public String word;
	
	/**
	 * "incorrectGuesses": a String list that stores all the incorrect guesses.
	 */
	public List<String> incorrectGuesses = new ArrayList<>();
	
	
	public List<String> wordsFamily = new ArrayList<>();
	
	Map<String[], Integer> shownFamily = new HashMap<String[], Integer>();
	
	/**
	 * This constructor initializes a traditional hangman game.
	 * @param path of the txt file
	 */
	EvilHangman(String path){
		// get the clean words list
		super(path);
		
		// get the random word
		this.word = this.getRandomWord();
		getWordsFamilyIni();
		// set the known word to "_____"
		this.knownWord = new String[this.word.length()];
		for(int i=0; i<this.getWordLength(); i++)
			this.knownWord[i] = "_ ";
		
		// print the original known word
		this.printKnownWord();
		
		// initialize the correct array
		this.correct = new boolean[this.word.length()];
	}
	
	// Methods
	/**
	 * This method randomly select a word from CleanWords list.
	 * @return RandomWord (String)
	 */
	String getRandomWord() {
		
		// get a random index
		Random r = new Random();
		int index = r.nextInt(this.cleanWords.size());
		
		// find the corresponding word
		String RandomWord = this.cleanWords.get(index);
		
		return RandomWord;
	}
	
	
	void getWordsFamilyIni() {
		for(int i=0; i<this.cleanWords.size(); i++) {
			if (this.cleanWords.get(i).length()==this.word.length()) {
				this.wordsFamily.add(this.cleanWords.get(i));
			}
		}
	}
	
	void getWordsFamily(String ch) {
		//String[] test;
		shownFamily.clear();
		for(int i=0; i<this.wordsFamily.size(); i++) {
			String[] test = this.knownWord.clone();
			for(int j=0; j<this.getWordLength(); j++) {
				if(ch.charAt(0) == this.wordsFamily.get(i).charAt(j))
				{
					test[j] = ch;
					}
			}
			
			if (!shownFamily.containsKey(test)) {
				//add key s with count (value) of 1
				shownFamily.put(test, 1);
			} else {
				//increment count (value) for key s
				shownFamily.replace(test, shownFamily.get(test) + 1);
			}
		}
		String[] a = null;
		a = getDiskMax(shownFamily).clone();
		List<String> wordsFamilynew = new ArrayList<>();
		for(int i=0; i<this.wordsFamily.size(); i++) {
			String[] test2 = this.knownWord.clone();
			for(int j=0; j<this.getWordLength(); j++) {
				if(ch.charAt(0) == this.wordsFamily.get(i).charAt(j))
				{
					test2[j] = ch;
					}
			}
			if (a==test2) {
				wordsFamilynew.add(this.wordsFamily.get(i));
			}
		}
		this.wordsFamily.clear();
		this.wordsFamily.addAll(wordsFamilynew);
		this.knownWord = a.clone();
	}
	
	
	private String[] getDiskMax(Map<String[], Integer> map) {
        List<Integer> list = new ArrayList<Integer>();
        for (String[] temp : map.keySet()) {
        	Integer value = map.get(temp);
            list.add(value);
        }
        double max = 0;
        for (int i = 0; i < list.size(); i++) {
            double curr = list.get(i);
            max = (max>curr)?max:curr;
        }
        for (String[] key : map.keySet()) {
            if (max == map.get(key)) {
                return key;
            }
        }
        return null;
 }
	
	/**
	 * This methods returns the type of current game.
	 * @return "traditional"
	 */
	String getGameType() {
		return "evil";
	}
	
	/**
	 * This method returns the length of the word.
	 * @return length
	 */
	int getWordLength() {
		int length = this.word.length();
		return length;
	}
	
	/**
	 * This method returns true when a character is a correct guess.
	 * This method also updates the correct array, known word and mistakes.
	 * @param ch
	 * @return true/false
	 */
	public boolean isCorrect(String ch) {
		getWordsFamily(ch);
		for(int i=0; i<this.getWordLength(); i++) {
			if(ch == this.knownWord[i])
				return true;
		}
		// update the mistakes
		this.mistakes += 1;
		return false;
	}
	
	/**
	 * This method shows all the incorrect guesses and add 
	 * last incorrect guess to the incorrectGuesses array.
	 * @param ch
	 */
	void incorrectGuesses(String ch) {
		
		// store the incorrect guess
		this.incorrectGuesses.add(ch);
		
		// show all the incorrect guesses
		System.out.print("Incorrect Guesses: ");
		for(int i=0; i<this.incorrectGuesses.size(); i++)
			System.out.print(this.incorrectGuesses.get(i) + " ");
		
		System.out.print("\n");
		
	}
}

